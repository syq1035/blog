---
title: 正则表达式
date: 2018-3-29 20:10:10
tags: 正则表达式
categories: web
---

> 对于正则表达式，第一眼都觉得很难，甚至不想去看它，觉得完全没有规律可寻，而且全是一堆各种各样的特殊符号，完全不知所云。

下面将详细介绍：

### 一.什么是正则表达式

>  正则表达式是一种特殊的字符串模式，用于匹配一组字符串，就好比用模具做产品，而正则就是这个模具，定义一种规则去匹配符合规则的字符。
<!-- more -->

### 二.正则表达式有什么用

- 测试字符串内的模式。
  例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。

- 替换文本。
  可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。

- 基于模式匹配从字符串中提取子字符串。
  可以查找文档内或输入域内特定的文本。

  > 例如，您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。

### 三.**正则字符介绍**

#### 1.元字符介绍

> **“^”** ：^会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置。 当在一组方括号里使用^是，它表示”非”或”排除”的意思，常常用来剔除某个字符。
>
> **“$”** ：$会匹配行或字符串的结尾。

#### 2.限定符

| 字符    | 描述                                       |
| ----- | ---------------------------------------- |
| *     | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 |
| +     | 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 |
| ?     | 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的 “does” 或 “doxy” 中的 “do” 。? 等价于 {0,1}。 |
| {n}   | n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 |
| {n,}  | n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 |
| {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 |

***、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。**

#### 4.确定重复出现

一个数字 {x} 的意思是**前面的字符或字符簇只出现x次** ；一个数字加逗号 {x,} 的意思是**前面的内容出现x或更多的次数** ；两个数字用逗号分隔的数字 {x,y} 表示 **前面的内容至少出现x次，但不超过y次**

```
^[a-zA-Z0-9_]{1,}$      // 所有包含一个以上的字母、数字或下划线的字符串 
^[1-9][0-9]{0,}$        // 所有的正整数 
^\-{0,1}[0-9]{1,}$      // 所有的整数 
^[-]?[0-9]+\.?[0-9]+$   // 所有的浮点数
```

特殊字符 *与 {0,} 是相等的，它们都代表着 \**0 个或多个前面的内容** 。最后，字符 + 与 {1,} 是相等的，表示 *1 个或多个前面的内容* ，所以上面的4个例子可以写成：

```
^[a-zA-Z0-9_]+$      // 所有包含一个以上的字母、数字或下划线的字符串 
^[1-9][0-9]*$        // 所有的正整数 
^\-?[0-9]+$          // 所有的整数 
^\-?[0-9]+\.?[0-9]*$ // 所有的浮点数
```

### 四.方法

`reg.test(str)` 判断字符串是否全是字母或数字

`str.replace(/[^0-9]+/ig,"")`将字符串转换为数字

`str.replace（/[^a-z]+/ig,""）`将字符串转换为纯字母

示例：把集合中相同的元素统计出数量，

collection = [ “a”, “a”, “a”,

 “e”, “e”, “e”, “e”, “e”, “e”, “e”,

 “h”, “h”, “h”, “h”, “h”, “h”, “h[3]”, “h”, “h”,

 “t”, “t-2”, “t”, “t”, “t”, “t”, “t”, “t”, “t[10]”,

 “f”, “f”, “f”, “f”, “f”, “f”, “f”, “f”, “f”,

 “c:8”,

 “g”, “g”, “g”, “g”, “g”, “g”, “g”,

 “b”, “b”, “b”, “b”, “b”, “b”,

 “d-5”

 ]

```
//判断字符串str是否是纯字符元素
function isAllChar(str){
  let reg = /^[a-z]+$/;
  if(reg.test(str)){
    return true;
  }else{
    return false;
  }
}
//把集合collection中相同的元素统计出数量，存入对象数组arr
function count(collection,arr){
  let obj = {};  
  let regNum = /[^0-9]+/ig;
  let regChar = /[^a-z]+/ig;
  let sum,name;
  for(let item of collection){
    if(isAllChar(item)){
      sum = 1;
      name=item;
    }else{
      sum = parseInt(item.replace(regNum,""));
      name = item.replace(regChar,"");
    }
    if(!obj[name]){
      obj[name] = {};
      obj[name].name = name;
      obj[name].summary = sum;
    }else{
      obj[name].summary =obj[name].summary+sum;
    }
  }
  for(let item in obj){
    arr.push(obj[item]);
  }
}

function count_same_elements(collection) {
  let result = [];
  count(collection,result);
  cosole.log(result);
  return result;
}

/*输出结果为[
      {name: "a", summary: 3},
      {name: "e", summary: 7},
      {name: "h", summary: 11},
      {name: "t", summary: 19},
      {name: "f", summary: 9},
      {name: "c", summary: 8},
      {name: "g", summary: 7},
      {name: "b", summary: 6},
      {name: "d", summary: 5}
    ]*/
```